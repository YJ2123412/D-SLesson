day05


-면접질문
1. 메소드의 정의- 왜 만드는 걸까요? (다른 프로그래밍 언어에서 '함수'와 같은 동작)
구조화(자주 사용하는 기능을 메인에서 분리, 코드를 여러번 작성하지 않고 재사용


2. 메소드의 인자, 매개변수란 무엇인가요?
메소드 실행에 필요한 입력값 / 의미상으로는 같은 말임
인자 agument: 둘 사이에 값을 공유, 연결함/ 메소드 호출(main 내)시 입력값을 메소드의 정의한 실행 부분(main 밖)으로 연결시킴
매개변수 : ()안에서 선언된 변수 그 자체.

인자로 넘겨, 매개변수 선언해

3. 메소드의 리턴은 무엇인가요?
메소드 실행의 결과(출력)값

4. static 메소드의 특징은 무엇인가요?  객체를 만들지 않고 class이름으로 직접 실행(호출), 
	(비교) 인스턴스 메소드는 객체를 만들어서 메소드를 호출   (객체 - msg, sc..)

	인스턴스 예시) msg.length(), sc.nextInt(); 
	static 예시) Character.isUpperCase(c), String.format(%d), Integer.valueOf("123")

	클래스.isUpperCase -대문자 인지?  /  클래스.isLowerCase - 소문자인지?   클래스.isDigit - 숫자인지


메소드는 인스턴스 메소드와 static메소드로 분류할 수 있음


--
Scanner sc= new SCanner ->
new:객체를 생성하는 것, 각각의 변수가 다 다른 값을 가질 수 있도록 해줌



-------
실매개변수: 실제 값이 있는 변수
형식매개변수: 아직 값이 정해지지 않은 변수

참조변수 - 값(데이터)이 아니라 / 배열의 시작 주소를 저장하는 변수 
-> 값을 찾기위해서 두번 접근해야함.. 주소를 찾고, 주소에 가서 값을 찾아옴



-----------------------------------
-데이터의 참조값

cArray[4] = ''; -> ''안에 비어있으면 오류.. 반드시 1글자 필요

배열 이름으로 출력하면 배열과 관련된 정보를 표시. 
그 정보에 참조값(식별값)이 포함됨, 변수가 다르면 식별값도 다르다

int [] temp;
temp = iArray; -> iArray의 주소를 temp에 주는 것


-hashcode = 참조값
hashcode는 참조값(식별값)을 만들기 위해 해쉬함수로 생성된 결과
       
System.out.println(iArray); 배열의 식별값을 보여줌
System.out.println(iArray.hashCode());  해쉬코드값을 가져옴(10진수)
System.out.println(Integer.toHexString(iArray.hashCode()));10진수를 16진수로 변환
배열값이 변경되어도 메모리의 주소가 바뀌진 않음
문자열은 내용이 변경되면 메모리의 위치가 바뀜 ->참조값 사용시 문자열은 String을 잘 쓰지않음.. 값이 자꾸 바뀌기에..

-객체란? 여러종류의 데이터가 모여있는 데이터 덩어리(기본형은 데이터 저장의 최소단위)
객체는 참조형 변수를 사용(변수가 주소를 저장)
객체를 메모리에 저장-> 초기 저장 데이터를 바꿀 수 있음(배열) - 가변객체
	     	  ->초기 저장 데이터를 바꿀 수 없음(String) - 주소가 달라지기에..  불변객체 (새로 생기는 것과 같음..)



기본형->아무리 길어도 8byte (double)
참조형->객체... 얼마나 길어질지알수없음




이 클래스는 객체를 생성할 때 사용할 원본(정의) 역할을 하는 클래스입니다. 
구성요소 : 필드(클래스의 특성을 나타내는 값), 메소드
	
필드 선언
String field1;
int field2;


배열은 참조타입이므로 참조타입 field3변수만 선언한 상태입니다.
배열도 객체입니다. 아직 객체는 생성이 안됬습니다.
double[] field3;   
초기값은 null
	

클래스는 객체를 만드는 틀이다
클래스 안에서 선언된 변수는 **전역변수(사용범위)
전역변수는 초기화 안해도 기본값이 저장됩니다.
	ㄴ참조형 타입은 null,수치 기본형 타입은 0  
	
상수: 값을 바꿀수 없는 상태의 데이터 (리터럴 상수, 기호상수)
final : 값을 변경할 수없다.반드시 초기화한다.
final int field4=999;     
	
*상수는 모든 객체가 같은 값이므로 공유영역에 저장하고
	ㄴ클래스 이름으로 접근한다. 식별자를 대문자로 한다. 
	ㄴ클래스의 성질을 나타내는 고정된(고유한) 값.
			
static : 클래스의 고유한 특성. 클래스 이름으로 접근한다. - (클래스의 형태에서 변하지 않는 부분)
인스턴스: 클래스의 형태에서 변하는 부분

static int field5;  값을 변경할수 있다.
	
static final int FIELD4=999;
final : 변경할 수 없는 변수
staitc final : 상수라고 합니다.


my1.field1 = 주체.변수명


메인이 없는 클래스는 실행을 할 수 없음, 단순히 데이터를 저장하거나 다른 클래스에서 호출하는 메소드를 정의하는 용도
------------------

오늘의 새로운 내용
1.객체를 만들었다. - new 연산
2. 객체는 인스턴스 필드와 인스턴스 메소드를 갖고 있으며 이것들은 객체가 주인이 되어 실행되어야 합니다.

객체변수가 momo일때 momo.getField1()에서 getField1()는 인스턴스 메소드입니다.

3. 객체의 인스턴스 필드는 private으로 접근을 제한하는 것이 객체지향의 특징입니다.
			ㄴ값을 읽어오는 getXXX, 값을 저장하는 setXXX메소드 만들기
4. 인스턴스 필드가 참조변수일때엔 '주소'의 개념을 꼭 먼저 생각하기
			getter, setter 메소드의 인자와 리턴값이 주소입니다.




 하나의 패키지 안에서 (메인 밖에서도) 선언한 메소드는 메모리에 자리잡고 있기에 다른 메소드에서도 활용해서 만들 수 있음


----------------------------과제
1. Score

 //학생들의 성적을 객체로 만들어줄 클래스입니다.
        
        private String name;//학생이름
        private int grade;  //학년
        private int[] jumsu; //점수들의 배열
//getter
//setter
//점수의 합계를 리턴하는 sum()메소드
//점수의 평균 double리턴하는 averager()메소드
//모든 인스턴스 필드값을 확인 출력하는 printScore() 메소드



2.  B03ScoreMain
//학생 4명의 성적을 저장해보세요
//1학년 2명(모모,다현) 3과목, 2학년 2명(나연,쯔위) 4과목, 점수는 임의로
 

//파일 두개 다 드라이브에 올리기



